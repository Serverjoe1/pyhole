#!/usr/bin/env python3

# pyhole - a clone of the Pi-hole DNS adblocker, written in Python.
# pyhole  (c) 2016 by ryt51V
# Pi-Hole (c) 2015, 2016 by Jacob Salmela

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# For running system commands
import os
# For getting the command line arguments we were run with.
import sys
# For named tuples
from collections import namedtuple
# For ncurses dialogs
# http://pythondialog.sourceforge.net/doc/Dialog_class_overview.html
# http://pythondialog.sourceforge.net/doc/widgets.html
from dialog import Dialog
# For parsing the config file
import configparser
# For managing apt packages
# https://apt.alioth.debian.org/python-apt-doc/library/apt.cache.html
# https://apt.alioth.debian.org/python-apt-doc/library/apt.package.html
import apt
# For IP addresses
import netifaces


# If not root, rerun as root with sudo.
if os.geteuid() != 0:
    print("Rerunning as root with sudo...")
    os.execvp("sudo", ["sudo"] + sys.argv)
#end if os.geteuid() != 0:

########################
###     Variables    ###
########################

config_dir = '/etc/pyhole'
share_dir  = '/usr/share/pyhole'
var_dir    = '/var/lib/pyhole'

# Define the web server named tuple
w = namedtuple('webserver',
               'name, package_name, install_description'
              )

web_servers = [
    w('lighttpd', 'lighttpd', 'Install pyhole and pyhole-admin files and lighttpd hosts.'),
    w('apache'  , 'apache2' , 'Install pyhole and pyhole-admin files and apache vhosts.' ),
    w('Manual'  , None      , 'Install pyhole and pyhole-admin files only.'),
]

apache_package   = 'apache2'
lighttpd_package = 'lighttpd'

########################
###   Configuration  ###
########################

# Create a dialog object we will use for all ncurses dialogs.
d = Dialog(autowidgetsize = True)
d.set_background_title("pyhole-config")

# Initialise our apt cache so we can check if packages are installed.
apt_cache = apt.Cache()

########################
###     Functions    ###
########################

def cancel_pressed():
    """Gracefully exit the script.  To be run whenever a user chooses cancel."""
    print("Cancel button pressed.  Exiting...")
    sys.exit()
#end def cancel_pressed():

def welcome_message():
    """Display any welcome messages."""
    msg = "This program will configure your pyhole."
    d.msgbox(msg)
#end def welcome_message:

def package_is_installed(package : str):
    """Return whether a package is installed."""
    if package in apt_cache:
        # Package is in the cache - not neccesarily installed
        return apt_cache[package].is_installed
    else:
        # Package is not in the cache - can't be installed.
        return False
    #end else
#end def package_is_installed(package):

def package_install(package : str):
    """Install a package"""
    if not package in apt_cache:
        print("Package {0} is not in the apt cache.".format(package) )
        raise
    #end if not package in apt_cache:
    
    if apt_cache[package].is_installed:
        print("Package {0} is already installed.".format(package) )
        raise
    #end if apt_cache[package].is_installed:
    
    apt_cache[package].mark_install
    apt_cache.commit()
    
    # Reload the changes to apt-cache
    apt_cache.open()
    
#end def package_install(package : str):

def choose_web_server():
    """Allow the user to choose the web server they want."""
    
    # Find out which of our choices are available.
    choices = []
    web_servers_installed = []
    
    for ws in web_servers:
        # The item for the "choice" list that we will pass to the menu dialog.
        choice = ( ws.name, ws.install_description )
        
        if ws.name == "Manual":
            # Manual is always an option.
            choices.append(choice)
        elif package_is_installed(ws.package_name):
            # Web servers are only an option if their package is installed.
            choices.append(choice)
            web_servers_installed.append(ws.package_name)
        #end if package_is_installed(ws['package_name']):
    #end for ws in web_servers:
    
    web_server_msgbox = "Pyhole requires a web server with two virtual hosts - one to serve an empty page that replaces ads, and one for the admin web interface to view stats and whitelist or blacklist ad servers.\n\n"
    
    web_server_msgbox += "Pyhole can automatically configure certain web servers for you if they are already installed.  Alternatively, pyhole can just install the web server files for you to use with a web server you configure manually yourself.\n\nThe web servers supported for automatic configuration are as follows:\n\n"
    
    for ws in web_servers:
        if ws.name != 'Manual': web_server_msgbox += "{0}\n".format(ws.package_name)
    #end for w in web_servers:
    
    d.msgbox(web_server_msgbox)
    
    if len(web_servers_installed) == 0:
        web_server_message = "No web servers supported for automatic configuration appear to be installed.  If you wish for pyhole to configure one for you then please cancel and install one of the supported web servers above.  Otherwise you may proceed with manual configuration.\n\nIf you are unsure, cancel this config and run the following before continuing:\n\nsudo apt-get install lighttpd"
    else:
        web_server_message = "Web servers supported for automatic configuration that are already installed web servers appear below.  Please choose an option.\n\nIf you are unsure, choose {0}."
    #end else:
    
    button, answer = d.menu(web_server_message, choices=choices)
    
    if button == d.CANCEL: cancel_pressed()
    
    return answer
    
#end def choose_web_server():

def choose_web_roots():
    """Allow the user to choose web roots."""
    web_root_message = "Choose where you would like pyhole to install the virtual hosts."
    
    elements = [
        ("pihole"      , 2, 2, "/var/www/pihole"      , 2, 20, 50, 255),
        ("pihole-admin", 4, 2, "/var/www/pihole-admin", 4, 20, 50, 255)
    ]
    
    button, answer = d.form(web_root_message, elements = elements, form_height = 5)
    
    if button == d.CANCEL: cancel_pressed()
    
    return answer
    
#end def chooce_web_roots():

def choose_interface():
    """Allow the user to choose their network interface."""
    interfaces = netifaces.interfaces()
    
    choices = []
    for i in interfaces:
        choice = ( i, "", False )
        if i != "lo":
            choices.append(choice)
        #end if i != "lo":
    #end for i in interfaces:
    
    message = "Please select a network interface.\n\nIf you are unsure, eth0 is almost always the best choice if you are using a wired connection."
    
    button, answer = d.radiolist(message, choices=choices)
    
    if button == d.CANCEL: cancel_pressed()
    
    return answer
    
#end def choose_interface():

def choose_ipv4_ipv6():
    """Allow the user to choose IPv4 and/or IPv6."""
    # Our choice of protocols.
    choices = [
        ('IPv4', "", True ),
        ('IPv6', "", False)
    ]
    
    message = 'Please select protocols.\n\nIf you are unsure, leave these as they are.'
    
    button, answer = d.checklist(text = message, choices=choices)
    
    if button == d.CANCEL: cancel_pressed()
    
    return answer
    
#end def choose_ipv4_ipv6():

def choose_ipv4_address(interface: str):
    """Allow the user to choose their IPv4 address on the provided interface."""
    # Get the IPv4 addresses on the given interface
    # AF_INET represents IPv4
    addrs = netifaces.ifaddresses(interface)[netifaces.AF_INET]
    
    # Get all of our choices
    # We index them as we want to return the full addr object.
    choices = []
    i = 0
    for a in addrs:
        description = "addr {0[addr]}  netmask {0[netmask]}  broadcast {0[broadcast]}".format(a)
        # The first argument needs to be a string; it won't work with int.
        choices.append( ( str(i), description, False ) )
        i += 1
    #end for a in addr:
    
    message = "Please select an IPv4 address on interface {0}.\n\nIf you are unsure, choose the first one.".format(interface)
    
    button, answer = d.radiolist(text = message, choices=choices)
    
    if button == d.CANCEL: cancel_pressed()
    
    # Get the object represented by the chosen list item.
    return addrs[int(answer)]
    
#def choose_ipv4_address():

def choose_ipv4_reconfigure(interface : str, ipv4_address):
    """Check whether the IPv4 address is static."""
    
    # There does not seem to be a decent way to tell whether or not an IPv4 address is static.
    # We will look in the file /etc/network/interfaces for the phrases below and judge.
    #   'iface <interface name> inet static'
    #   'iface <interface name> inet dhcp'
    # Yes this could fail for many reasons including use of /etc/network/interfaces, so we won't
    # make hard decisions based on this.
    
    ipv4_address_type = 'unknown'
    
    static_search_string    = 'iface {0} inet static'.format(interface)
    dynamic_search_string   = 'iface {0} inet dhcp'.format(interface)
    
    with open('/etc/network/interfaces', 'r') as f:
        interfaces_file = f.read()
    #end with open('/etc/network/interfaces', 'r') as f:
    
    if static_search_string in interfaces_file:
        ipv4_address_type = 'static'
    elif dynamic_search_string in interfaces_file:
        ipv4_address_type = 'dynamic'
    #end elif dynamic_search_string in interfaces_file:
    
    message = "As Pyhole will be running a DNS server, it is essential that your internal IPv4 address is static.  A dynamic IPv4 address is not suitable.  (A DHCP reservation may work in some situations but is not recommended.)\n\n"
    
    if ipv4_address_type == 'static':
        message += "It looks like your IPv4 address {0[addr]} on interface {1} is already static, which is good.\n\n".format(ipv4_address, interface)
    elif ipv4_address_type == 'dynamic':
        message += "It looks like your IPv4 address {0[addr]} on interface {1} is dynamic.  You need to have a static IP.\n\n".format(ipv4_address, interface)
    else:
        message += "We're unable to tell whether your address {0[addr]} on interface {1} is dynamic or static.\n\n".format(ipv4_address, interface)
    #end else:
    
    if ipv4_address_type == 'static':
        message += "If you are unsure, choose to keep your current network settings."
    else:
        message += "Pyhole can set a static IPv4 address for you, though if you know how to set one yourself within Linux it is recommended you configure this outside of Pyhole.\n\nIf you are unsure, choose to configure a static IPv4 address."
    #end else:
    
    choices = [
        ( "Keep"  , "Keep my IPv4 address settings as is." ),
        ( "Configure", "Configure a static IPv4 address for me." )
    ]
    
    button, answer = d.menu(message, choices=choices)
    
    if button == d.CANCEL: cancel_pressed()
    
    return answer
    
#end def check_ipv4_static():

########################
###       Begin      ###
########################

# Choose a web server and web root paths.
web_server = choose_web_server()
pihole_web_root, pihole_admin_web_root = choose_web_roots()

# Choose an interface, whether using IPv4 and/or IPv6, and addresses.
interface = choose_interface()

protocols = choose_ipv4_ipv6()

if 'IPv4' in protocols:
    ipv4_address = choose_ipv4_address(interface)
    ipv4_reconfigure = choose_ipv4_reconfigure(interface, ipv4_address)
#end if 'IPv4' in protocols:

if 'IPv6' in protocols:
    pass
#end if 'IPv6' in protocols:

